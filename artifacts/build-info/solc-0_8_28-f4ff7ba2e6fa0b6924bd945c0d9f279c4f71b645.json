{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-f4ff7ba2e6fa0b6924bd945c0d9f279c4f71b645",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/MedicalRecordAccess.sol": "project/contracts/MedicalRecordAccess.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "london",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MedicalRecordAccess.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IMedicalRecords {\n    function getRecords(address _patient) external view returns (string[] memory);\n    function getKeyShare(string memory _ipfsCid) external view returns (bytes memory);\n    function grantAccess(address grantee, string calldata ipfsCid, bytes calldata encryptedKeyShare) external;\n}\n\ninterface IHealthConsent {\n    function getConsent(address _patient) external view returns (bool, uint256, string memory);\n}\n\ncontract MedicalRecordAccess {\n    IMedicalRecords public medicalRecords;\n    IHealthConsent public healthConsent;\n\n    struct AccessGrant {\n        address patient;\n        address grantee;\n        string ipfsCid;\n        uint256 expiration;\n        uint256 timestamp;\n    }\n\n    mapping(address => mapping(address => mapping(string => AccessGrant))) public grants;\n    mapping(address => mapping(address => string[])) private granteeAccessList;\n\n    event AccessGranted(address indexed patient, address indexed grantee, string ipfsCid, uint256 expiration);\n    event AccessRevoked(address indexed patient, address indexed grantee, string ipfsCid);\n\n    constructor(address _medicalRecordsAddress, address _healthConsentAddress) {\n        require(_medicalRecordsAddress != address(0), \"Invalid medical records address\");\n        require(_healthConsentAddress != address(0), \"Invalid consent contract address\");\n        medicalRecords = IMedicalRecords(_medicalRecordsAddress);\n        healthConsent = IHealthConsent(_healthConsentAddress);\n    }\n\n    function grantAccess(address grantee, string calldata ipfsCid, uint256 expiration, bytes calldata encryptedKeyShare) external {\n        require(grantee != address(0), \"Invalid grantee address\");\n        require(bytes(ipfsCid).length > 0, \"Invalid IPFS CID\");\n        require(encryptedKeyShare.length > 0, \"Invalid encrypted key share\");\n\n        (bool hasSigned, , ) = healthConsent.getConsent(msg.sender);\n        require(hasSigned, \"Consent not signed\");\n\n        // Verify record exists and patient owns it\n        bool recordExists = false;\n        string[] memory records = medicalRecords.getRecords(msg.sender);\n        for (uint256 i = 0; i < records.length; i++) {\n            if (keccak256(abi.encodePacked(records[i])) == keccak256(abi.encodePacked(ipfsCid))) {\n                recordExists = true;\n                break;\n            }\n        }\n        require(recordExists, \"Record not found\");\n\n        // Call MedicalRecords.grantAccess with try-catch to handle reverts\n        try medicalRecords.grantAccess(grantee, ipfsCid, encryptedKeyShare) {\n            // Store access grant\n            grants[msg.sender][grantee][ipfsCid] = AccessGrant({\n                patient: msg.sender,\n                grantee: grantee,\n                ipfsCid: ipfsCid,\n                expiration: expiration,\n                timestamp: block.timestamp\n            });\n\n            // Update grantee access list\n            bool exists = false;\n            string[] storage cids = granteeAccessList[grantee][msg.sender];\n            for (uint256 i = 0; i < cids.length; i++) {\n                if (keccak256(abi.encodePacked(cids[i])) == keccak256(abi.encodePacked(ipfsCid))) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                granteeAccessList[grantee][msg.sender].push(ipfsCid);\n            }\n\n            emit AccessGranted(msg.sender, grantee, ipfsCid, expiration);\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(\"MedicalRecords.grantAccess failed: \", reason)));\n        } catch {\n            revert(\"MedicalRecords.grantAccess failed with unknown error\");\n        }\n    }\n\n    // Revoke access for a grantee\n    function revokeAccess(address grantee, string calldata ipfsCid) external {\n        require(grants[msg.sender][grantee][ipfsCid].patient == msg.sender, \"No access grant found\");\n\n        delete grants[msg.sender][grantee][ipfsCid];\n\n        string[] storage cids = granteeAccessList[grantee][msg.sender];\n        for (uint256 i = 0; i < cids.length; i++) {\n            if (keccak256(abi.encodePacked(cids[i])) == keccak256(abi.encodePacked(ipfsCid))) {\n                cids[i] = cids[cids.length - 1];\n                cids.pop();\n                break;\n            }\n        }\n\n        emit AccessRevoked(msg.sender, grantee, ipfsCid);\n    }\n\n    function hasAccess(address patient, address grantee, string calldata ipfsCid) external view returns (bool) {\n        AccessGrant memory grant = grants[patient][grantee][ipfsCid];\n        if (grant.grantee == address(0)) {\n            return false;\n        }\n        return grant.expiration == 0 || block.timestamp < grant.expiration;\n    }\n\n    function getEncryptedKeyShare(address patient, string calldata ipfsCid) external view returns (bytes memory) {\n        AccessGrant memory grant = grants[patient][msg.sender][ipfsCid];\n        require(grant.grantee != address(0), \"No access grant found\");\n        require(grant.expiration == 0 || block.timestamp < grant.expiration, \"Access expired\");\n        return medicalRecords.getKeyShare(ipfsCid);\n    }\n\n    function getGranteeAccess(address grantee, address patient) external view returns (string[] memory) {\n        string[] memory cids = granteeAccessList[grantee][patient];\n        if (cids.length == 0) {\n            return new string[](0);\n        }\n\n        uint256 validCount = 0;\n        for (uint256 i = 0; i < cids.length; i++) {\n            AccessGrant memory grant = grants[patient][grantee][cids[i]];\n            if (grant.grantee != address(0) && (grant.expiration == 0 || block.timestamp < grant.expiration)) {\n                validCount++;\n            }\n        }\n\n        string[] memory validCids = new string[](validCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < cids.length; i++) {\n            AccessGrant memory grant = grants[patient][grantee][cids[i]];\n            if (grant.grantee != address(0) && (grant.expiration == 0 || block.timestamp < grant.expiration)) {\n                validCids[index] = cids[i];\n                index++;\n            }\n        }\n        return validCids;\n    }\n}"
      }
    }
  }
}