{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-7faca43e69e8c58f8729e12af30de78c73806a0c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Consent.sol": "project/contracts/Consent.sol",
    "contracts/MedicalRecords.sol": "project/contracts/MedicalRecords.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "london",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Consent.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract ConsentManager {\n    struct Consent {\n        bool hasSigned;\n        uint256 timestamp;\n        string consentHash;\n        string ipfsCid; // Added for IPFS storage\n    }\n\n    // Map patient address to array of consents for history\n    mapping(address => Consent[]) private consents;\n\n    event ConsentSigned(\n        address indexed patient,\n        uint256 timestamp,\n        string consentHash,\n        string ipfsCid\n    );\n\n    function signConsent(address _patient, string memory _consentHash, string memory _ipfsCid) external returns (bool) {\n        require(_patient != address(0), \"Invalid patient address\");\n        require(bytes(_consentHash).length > 0, \"Invalid consent hash\");\n        require(msg.sender == _patient, \"Only patient can sign consent\");\n\n        Consent memory newConsent = Consent({\n            hasSigned: true,\n            timestamp: block.timestamp,\n            consentHash: _consentHash,\n            ipfsCid: _ipfsCid\n        });\n\n        consents[_patient].push(newConsent);\n        emit ConsentSigned(_patient, block.timestamp, _consentHash, _ipfsCid);\n        return true;\n    }\n\n    function getConsent(address _patient) external view returns (Consent[] memory) {\n        return consents[_patient];\n    }\n\n    function hasSignedConsent(address _patient) external view returns (bool) {\n        return consents[_patient].length > 0;\n    }\n}"
      },
      "project/contracts/MedicalRecords.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IHealthConsent {\n    function getConsent(address _patient) external view returns (bool, uint256, string memory);\n}\n\ncontract MedicalRecords {\n    IHealthConsent public healthConsent;\n\n    // Event emitted when a record is uploaded with IPFS CID\n    event RecordUploaded(address indexed patient, uint256 timestamp, string ipfsCid);\n\n    // Event emitted when access is granted\n    event AccessGranted(address indexed patient, address indexed authorized, string ipfsCid);\n\n    // Mapping to store IPFS CIDs of uploaded records\n    mapping(address => string[]) private patientRecords;\n\n    // Mapping for encrypted key shares: patient => ipfsCid => authorized => encryptedKeyShare\n    // (authorized can be the patient themselves for self-access)\n    mapping(address => mapping(string => mapping(address => bytes))) private keyShares;\n\n    // Mapping to track ownership: ipfsCid => patient (for quick lookup in getKeyShare)\n    mapping(string => address) private cidToPatient;\n\n    constructor(address _healthConsentAddress) {\n        require(_healthConsentAddress != address(0), \"Invalid consent contract address\");\n        healthConsent = IHealthConsent(_healthConsentAddress);\n    }\n\n    // Upload IPFS CID for a medical record, including patient's self-encrypted key share\n    function uploadRecord(string memory _ipfsCid, bytes memory _selfEncryptedKeyShare) public returns (bool) {\n        address _patient = msg.sender;  // Assume caller is the patient\n        (bool hasSigned, , ) = healthConsent.getConsent(_patient);\n        require(hasSigned, \"Consent not signed\");\n        require(bytes(_ipfsCid).length > 0, \"Invalid IPFS CID\");\n        require(_selfEncryptedKeyShare.length > 0, \"Must provide self-encrypted key share\");\n\n        patientRecords[_patient].push(_ipfsCid);\n        cidToPatient[_ipfsCid] = _patient;\n        keyShares[_patient][_ipfsCid][_patient] = _selfEncryptedKeyShare;  // Store patient's own key share\n\n        emit RecordUploaded(_patient, block.timestamp, _ipfsCid);\n        return true;\n    }\n\n    // Grant access to an authorized address (e.g., doctor) for a specific CID\n    function grantAccess(address _authorized, string memory _ipfsCid, bytes memory _encryptedKeyShare) public {\n        address _patient = msg.sender;  // Caller must be patient\n        require(cidToPatient[_ipfsCid] == _patient, \"Only patient can grant access\");\n        require(_authorized != address(0), \"Invalid authorized address\");\n        require(_encryptedKeyShare.length > 0, \"Invalid encrypted key share\");\n\n        keyShares[_patient][_ipfsCid][_authorized] = _encryptedKeyShare;\n        emit AccessGranted(_patient, _authorized, _ipfsCid);\n    }\n\n    // Retrieve the caller's encrypted key share for a CID (if authorized or owner)\n    function getKeyShare(string memory _ipfsCid) public view returns (bytes memory) {\n        address _patient = cidToPatient[_ipfsCid];\n        require(_patient != address(0), \"Invalid CID\");\n        bytes memory share = keyShares[_patient][_ipfsCid][msg.sender];\n        require(share.length > 0, \"No access to this record\");\n        return share;\n    }\n\n    // Retrieve patient's uploaded record CIDs\n    function getRecords(address _patient) public view returns (string[] memory) {\n        return patientRecords[_patient];\n    }\n}"
      }
    }
  }
}