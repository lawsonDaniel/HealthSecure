{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-1c256389e4e8901bb8a010cbbc6fce2556d377b5",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/MedicalRecordAccess.sol": "project/contracts/MedicalRecordAccess.sol",
    "contracts/RecordTransfer.sol": "project/contracts/RecordTransfer.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "london",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MedicalRecordAccess.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// contracts/MedicalRecordAccess.sol\npragma solidity ^0.8.28;\n\ninterface IMedicalRecords {\n    function getRecords(address _patient) external view returns (string[] memory);\n}\n\ninterface IHealthConsent {\n    function getConsent(address _patient) external view returns (bool, uint256, string memory);\n}\n\ncontract MedicalRecordAccess {\n    IMedicalRecords public medicalRecords;\n    IHealthConsent public healthConsent;\n\n    struct AccessGrant {\n        address patient;\n        address grantee;\n        string ipfsCid;\n        uint256 expiration;\n        uint256 timestamp;\n    }\n\n    // Mapping: patient => grantee => ipfsCid => AccessGrant\n    mapping(address => mapping(address => mapping(string => AccessGrant))) public grants;\n\n    event AccessGranted(\n        address indexed patient,\n        address indexed grantee,\n        string ipfsCid,\n        uint256 expiration\n    );\n\n    event AccessRevoked(\n        address indexed patient,\n        address indexed grantee,\n        string ipfsCid\n    );\n\n    constructor(address _medicalRecordsAddress, address _healthConsentAddress) {\n        require(_medicalRecordsAddress != address(0), \"Invalid medical records address\");\n        require(_healthConsentAddress != address(0), \"Invalid consent contract address\");\n        medicalRecords = IMedicalRecords(_medicalRecordsAddress);\n        healthConsent = IHealthConsent(_healthConsentAddress);\n    }\n\n    /**\n     * @dev Grants access to a specific medical record (IPFS CID) to a grantee.\n     * @param grantee The address of the healthcare provider or recipient.\n     * @param ipfsCid The IPFS CID of the medical record.\n     * @param expiration The timestamp after which access expires (0 for indefinite).\n     */\n    function grantAccess(\n        address grantee,\n        string calldata ipfsCid,\n        uint256 expiration\n    ) external {\n        require(grantee != address(0), \"Invalid grantee address\");\n        require(bytes(ipfsCid).length > 0, \"Invalid IPFS CID\");\n\n        // Verify patient has signed consent\n        (bool hasSigned, , ) = healthConsent.getConsent(msg.sender);\n        require(hasSigned, \"Consent not signed\");\n\n        // Verify the record exists\n        bool recordExists = false;\n        string[] memory records = medicalRecords.getRecords(msg.sender);\n        for (uint256 i = 0; i < records.length; i++) {\n            if (keccak256(abi.encodePacked(records[i])) == keccak256(abi.encodePacked(ipfsCid))) {\n                recordExists = true;\n                break;\n            }\n        }\n        require(recordExists, \"Record not found\");\n\n        grants[msg.sender][grantee][ipfsCid] = AccessGrant({\n            patient: msg.sender,\n            grantee: grantee,\n            ipfsCid: ipfsCid,\n            expiration: expiration,\n            timestamp: block.timestamp\n        });\n\n        emit AccessGranted(msg.sender, grantee, ipfsCid, expiration);\n    }\n\n    /**\n     * @dev Revokes access to a specific medical record for a grantee.\n     * @param grantee The address of the grantee.\n     * @param ipfsCid The IPFS CID of the medical record.\n     */\n    function revokeAccess(address grantee, string calldata ipfsCid) external {\n        require(grants[msg.sender][grantee][ipfsCid].patient == msg.sender, \"No access grant found\");\n\n        delete grants[msg.sender][grantee][ipfsCid];\n\n        emit AccessRevoked(msg.sender, grantee, ipfsCid);\n    }\n\n    /**\n     * @dev Checks if a grantee has access to a patient's specific medical record.\n     * @param patient The address of the patient.\n     * @param grantee The address of the grantee.\n     * @param ipfsCid The IPFS CID of the medical record.\n     * @return bool True if access is granted and not expired.\n     */\n    function hasAccess(\n        address patient,\n        address grantee,\n        string calldata ipfsCid\n    ) external view returns (bool) {\n        AccessGrant memory grant = grants[patient][grantee][ipfsCid];\n        if (grant.grantee == address(0)) {\n            return false;\n        }\n        return grant.expiration == 0 || block.timestamp < grant.expiration;\n    }\n}"
      },
      "project/contracts/RecordTransfer.sol": {
        "content": "// contracts/RecordTransfer.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IHealthConsent {\n    function getConsent(address _patient) external view returns (bool, uint256, string memory);\n}\n\ncontract RecordTransfer {\n    struct Transfer {\n        address from;\n        address to;\n        string ipfsCid;\n        uint256 timestamp;\n        bool revoked;\n        string purpose;\n    }\n\n    struct AccessLog {\n        address accessedBy;\n        uint256 timestamp;\n        string ipfsCid;\n        string purpose;\n    }\n\n    struct AuthorizedProvider {\n        address provider;\n        uint256 grantedAt;\n        bool isActive;\n    }\n\n    mapping(address => Transfer[]) private patientTransfers;\n    mapping(address => AccessLog[]) private accessLogs;\n    mapping(address => mapping(address => bool)) private authorizedProviders;\n    mapping(address => address[]) private patientProviders; // Index for authorized providers\n    \n    IHealthConsent public healthConsent;\n\n    event RecordTransferred(\n        address indexed patient,\n        address indexed provider,\n        string ipfsCid,\n        uint256 timestamp,\n        string purpose\n    );\n\n    event AccessRevoked(\n        address indexed patient,\n        address indexed provider,\n        string ipfsCid,\n        uint256 timestamp\n    );\n\n    event AccessGranted(\n        address indexed patient,\n        address indexed provider,\n        uint256 timestamp\n    );\n\n    event AccessLogged(\n        address indexed patient,\n        address indexed accessedBy,\n        string ipfsCid,\n        uint256 timestamp,\n        string purpose\n    );\n\n    constructor(address _healthConsentAddress) {\n        healthConsent = IHealthConsent(_healthConsentAddress);\n    }\n\n    modifier onlyWithConsent(address patient) {\n        (bool hasConsent, , ) = healthConsent.getConsent(patient);\n        require(hasConsent, \"Patient has not signed consent\");\n        _;\n    }\n\n    function transferRecord(\n        address _provider,\n        string memory _ipfsCid,\n        string memory _purpose\n    ) public onlyWithConsent(msg.sender) returns (bool) {\n        require(_provider != address(0), \"Invalid provider address\");\n        require(_provider != msg.sender, \"Cannot transfer to yourself\");\n        require(bytes(_ipfsCid).length > 0, \"IPFS CID cannot be empty\");\n        require(bytes(_purpose).length > 0, \"Purpose cannot be empty\");\n\n        // Grant access to provider if not already granted\n        if (!authorizedProviders[msg.sender][_provider]) {\n            authorizedProviders[msg.sender][_provider] = true;\n            patientProviders[msg.sender].push(_provider);\n            emit AccessGranted(msg.sender, _provider, block.timestamp);\n        }\n\n        // Record the transfer\n        patientTransfers[msg.sender].push(Transfer({\n            from: msg.sender,\n            to: _provider,\n            ipfsCid: _ipfsCid,\n            timestamp: block.timestamp,\n            revoked: false,\n            purpose: _purpose\n        }));\n\n        emit RecordTransferred(\n            msg.sender,\n            _provider,\n            _ipfsCid,\n            block.timestamp,\n            _purpose\n        );\n\n        return true;\n    }\n\n    function revokeAccess(address _provider, string memory _ipfsCid) public returns (bool) {\n        require(_provider != address(0), \"Invalid provider address\");\n        \n        // Revoke access\n        authorizedProviders[msg.sender][_provider] = false;\n\n        // Mark transfer as revoked\n        for (uint i = 0; i < patientTransfers[msg.sender].length; i++) {\n            if (\n                patientTransfers[msg.sender][i].to == _provider &&\n                keccak256(bytes(patientTransfers[msg.sender][i].ipfsCid)) == keccak256(bytes(_ipfsCid)) &&\n                !patientTransfers[msg.sender][i].revoked\n            ) {\n                patientTransfers[msg.sender][i].revoked = true;\n                break;\n            }\n        }\n\n        emit AccessRevoked(msg.sender, _provider, _ipfsCid, block.timestamp);\n        return true;\n    }\n\n    function revokeAllAccess(address _provider) public returns (bool) {\n        require(_provider != address(0), \"Invalid provider address\");\n        \n        // Revoke all access\n        authorizedProviders[msg.sender][_provider] = false;\n\n        // Mark all transfers to this provider as revoked\n        for (uint i = 0; i < patientTransfers[msg.sender].length; i++) {\n            if (\n                patientTransfers[msg.sender][i].to == _provider &&\n                !patientTransfers[msg.sender][i].revoked\n            ) {\n                patientTransfers[msg.sender][i].revoked = true;\n            }\n        }\n\n        emit AccessRevoked(msg.sender, _provider, \"ALL_RECORDS\", block.timestamp);\n        return true;\n    }\n\n    function grantAccess(address _provider) public onlyWithConsent(msg.sender) returns (bool) {\n        require(_provider != address(0), \"Invalid provider address\");\n        require(_provider != msg.sender, \"Cannot grant access to yourself\");\n        \n        authorizedProviders[msg.sender][_provider] = true;\n        \n        // Add to providers list if not already there\n        bool alreadyExists = false;\n        for (uint i = 0; i < patientProviders[msg.sender].length; i++) {\n            if (patientProviders[msg.sender][i] == _provider) {\n                alreadyExists = true;\n                break;\n            }\n        }\n        \n        if (!alreadyExists) {\n            patientProviders[msg.sender].push(_provider);\n        }\n        \n        emit AccessGranted(msg.sender, _provider, block.timestamp);\n        return true;\n    }\n\n    function logAccess(\n        address _patient,\n        string memory _ipfsCid,\n        string memory _purpose\n    ) public returns (bool) {\n        require(authorizedProviders[_patient][msg.sender], \"Not authorized to access this patient's records\");\n        require(bytes(_ipfsCid).length > 0, \"IPFS CID cannot be empty\");\n        require(bytes(_purpose).length > 0, \"Purpose cannot be empty\");\n\n        accessLogs[_patient].push(AccessLog({\n            accessedBy: msg.sender,\n            timestamp: block.timestamp,\n            ipfsCid: _ipfsCid,\n            purpose: _purpose\n        }));\n\n        emit AccessLogged(_patient, msg.sender, _ipfsCid, block.timestamp, _purpose);\n        return true;\n    }\n\n    function getTransfers(address _patient) public view returns (Transfer[] memory) {\n        require(msg.sender == _patient || authorizedProviders[_patient][msg.sender], \"Not authorized\");\n        return patientTransfers[_patient];\n    }\n\n    function getAccessLogs(address _patient) public view returns (AccessLog[] memory) {\n        require(msg.sender == _patient, \"Only patient can view access logs\");\n        return accessLogs[_patient];\n    }\n\n    function hasAccess(address _patient, address _provider) public view returns (bool) {\n        return authorizedProviders[_patient][_provider];\n    }\n\n    function getAuthorizedProviders(address _patient) public view returns (address[] memory) {\n        require(msg.sender == _patient, \"Only patient can view authorized providers\");\n        \n        // Count active providers\n        uint activeCount = 0;\n        for (uint i = 0; i < patientProviders[_patient].length; i++) {\n            if (authorizedProviders[_patient][patientProviders[_patient][i]]) {\n                activeCount++;\n            }\n        }\n        \n        // Return only active providers\n        address[] memory activeProviders = new address[](activeCount);\n        uint currentIndex = 0;\n        \n        for (uint i = 0; i < patientProviders[_patient].length; i++) {\n            address provider = patientProviders[_patient][i];\n            if (authorizedProviders[_patient][provider]) {\n                activeProviders[currentIndex] = provider;\n                currentIndex++;\n            }\n        }\n        \n        return activeProviders;\n    }\n\n    function getTransferCount(address _patient) public view returns (uint) {\n        require(msg.sender == _patient || authorizedProviders[_patient][msg.sender], \"Not authorized\");\n        return patientTransfers[_patient].length;\n    }\n}"
      }
    }
  }
}